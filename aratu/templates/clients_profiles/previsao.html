{% extends 'clients_profiles/base.html' %}

{% block title %}Previsão{% endblock %}

{% block content %}
<!DOCTYPE html>
<html>
<head>
    <meta name="csrf-token" content="{{ csrf_token }}">
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        
        #titulo {
            margin: 5px;
        }

        .form-group {
            margin-bottom: 5px;
        }

        #data-preview table {
            border-collapse: collapse;
            width: 100%;
        }

        #data-preview th, #data-preview td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        #data-preview th {
            background-color: #f2f2f2;
            text-align: left;
        }

        button {
            margin: 2px;
            padding: 5px 10px;
            border: none;
            background-color: #007BFF;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        #data-preview {
            margin-top: 5px;
            padding: 5px;
            border: 1px solid #ccc;
            display: none;
        }

        #myChart {
            max-height: fit-content;/*300px;*/
            max-width: fit-content;
        }

        .chart {
            margin: 5px;
        }

        .line {
            fill: none;
            stroke-width: 2;
        }

        .line-real {
            stroke: steelblue;
        }

        .line-forecast {
            stroke: orange;
        }
        .plote-container {
          display: flex;
          height: 100%;
        }
        #map {
            min-height: 260px;
            height: calc(100vh - 360px); /* Ajuste 300px conforme a altura dos elementos acima do mapa */
            flex-grow: 1;
            width: 100%;
            margin: 5px;
        }
        #subtitulo {
            margin: 5px;
        }
        #cluster-form {
          display: flex;         /* Ativa o layout flexível */
          flex-wrap: wrap;       /* Permite que os itens quebrem para a próxima linha */
          gap: 3px 3px;        /* Adiciona espaçamento: 10px vertical, 20px horizontal */
        }

        #cluster-form label {
          /* Define uma base de largura para cada item. */
          /* O navegador tentará colocar o máximo de itens de 150px em cada linha. */
          flex-basis: 110px; 
          
          /* Evita que os itens encolham demais */
          flex-shrink: 0;
          
          /* Outras estilizações para deixar mais bonito */
          padding: 2px;
          border: 1px solid #eee;
          border-radius: 4px;
          background-color: #f9f9f9;
        }
        #cluster-selection {
          display: none;
          margin: 5px 0;
          padding: 5px;
          border: 1px solid #ccc;
          border-radius: 5px;
        }
        #forecast-period {
          width: 100px; /* Ajuste o valor como preferir. 100px é um bom começo. */
        }
        #row-data-limits {
          margin: 5px;
        }

    </style>
    <!-- Dependências do DataTables -->
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="text/javascript" charset="utf8" src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script type="text/javascript" charset="utf8"
            src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!--<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>-->
</head>
<body>
<h1 id="titulo">Página de Previsão</h1>
{% if perms.clients_profiles.view_airqualitydata %}
<form id="date-form" method="POST">
    <div class="form-group">
        <label for="start-date">Data de Início:</label>
        <input type="date" id="start-date" name="start-date" required>
        <label for="end-date">Data de Fim:</label>
        <input type="date" id="end-date" name="end-date" required>
        <label for="forecast-period">Período de Previsão (dias):</label>
        <input type="number" id="forecast-period" name="forecast-period" min="1" value="7" required>
    </div>
    <p id="row-data-limits">Intervalo de Datas: <span id="min-date-display"></span> até <span id="max-date-display"></span></p>
    <!--
    ##############################################################################################################################################################
    Unir execuções dos botões 'Criar Cluster' & 'Definir Regioes'
    ##############################################################################################################################################################
    -->
    <div id="processing-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; color: white; font-size: 1.5em;">
    <p id="processing-message">Processando...</p>
    </div>
    <button id="generate-cluster" type="button" disabled>Criar Cluster Geográfico</button>
    <!--<button id="define-regions" type="button" style="display: none;">Definir Regiões</button>-->
    <button id="train-model-a" type="button" style="display: none;"> Fazer Previsão</button>
    <button id="information-button" type="button">?</button>
    <div id="information-box" style="display: none; border: 2px solid #00000088; margin-top: 10px;">
        <p id="info-interface">Variáveis da Interface:</p>
        <ul id="info-variables">
            <li>Data de Início: define a data inicial do intervalo a ser analisado.</li>
            <li>Data de Fim: define a data final do intervalo a ser analisado.</li>
            <li>Período de Previsão: define quantos dias serão previstos com base no modelo gerado.</li>
            <li>Cluster Geográfico: define as regiões de previsão por meio do agrupamento de pontos de dados semelhantes.</li>
        </ul>
        <p id="info-forecast">Variáveis da Previsão:</p>
        <ul id="info-variables">
            <li>cluster: identifica a qual cluster geográfico a previsão corresponde.</li>
            <li>pm: representa o valor previsto de material particulado.</li>
            <li>temp: indica a temperatura prevista.</li>
            <li>date: corresponde à data referente a cada previsão.</li>
        </ul>
    </div>
    <!--
    ##############################################################################################################################################################
    Add mensangem para quando não tiver previsão e usuario clicar em relatório
    ##############################################################################################################################################################
    -->
</form>
 {% else %}
    <p class="text-danger">
      Você não tem permissão para acessar esta página de previsão.
    </p>
  {% endif %}
<div id="data-preview"></div>
<div id="cluster-selection">
    <h3 id="subtitulo">Selecione os Clusters:</h3>
    <form id="cluster-form"></form>
</div>
<div id="map"></div>
<div id="plot-container" style="margin: 5px;"></div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    const forecastPeriodInput = document.getElementById('forecast-period');
    const clusterButton = document.getElementById('generate-cluster');
    const trainModelButton = document.getElementById('train-model-a');
    const informationButton = document.getElementById('information-button');
    const informationBox = document.getElementById('information-box');

    const processingOverlay = document.getElementById('processing-overlay');
    const processingMessage = document.getElementById('processing-message');

    /**
     * Mostra a UI de processamento com uma mensagem opcional.
     * @param {string} [message='Processando...'] - A mensagem a ser exibida.
     */
    function showProcessingUI(message = 'Processando...') {
      if (processingOverlay) {
        processingMessage.textContent = message;
        processingOverlay.style.display = 'flex'; // Usamos 'flex' para centralizar o conteúdo
      }
    }

    /**
     * Esconde a UI de processamento.
     */
    function hideProcessingUI() {
      if (processingOverlay) {
        processingOverlay.style.display = 'none';
      }
    }
    // Helper para CSRF
    function getCSRFToken() {
      return document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    }

    // Reset completo da interface
    function resetInterface() {
      // 1) Remove mapa antigo
      if (window.trainedMap) {
        window.trainedMap.remove();
        window.trainedMap = null;
      }

      // 2) Limpa gráficos
      const plotContainer = document.getElementById('plot-container');
      if (plotContainer) plotContainer.innerHTML = '';

      // 3) Limpa checkboxes de cluster
      const clusterForm = document.getElementById('cluster-form');
      if (clusterForm) clusterForm.innerHTML = '';

      // 4) Oculta seções
      const clusterSelectionDiv = document.getElementById('cluster-selection');
      if (clusterSelectionDiv) clusterSelectionDiv.style.display = 'none';

      const dataPreviewDiv = document.getElementById('data-preview');
      if (dataPreviewDiv) {
        dataPreviewDiv.style.display = 'none';
        dataPreviewDiv.innerHTML = '';
      }

      // 5) Oculta botão de previsão
      trainModelButton.style.display = 'none';
    }

    // Habilita botão de cluster
    function toggleClusterButton() {
      const startDate = new Date(startDateInput.value);
      const endDate = new Date(endDateInput.value);
      const forecastPeriod = parseInt(forecastPeriodInput.value);
      const valid = !isNaN(startDate) && !isNaN(endDate) && !isNaN(forecastPeriod)
        && forecastPeriod > 0 && startDate < endDate;
      clusterButton.disabled = !valid;
    }

    // Exibe caixa de texto com explicações das variaveis
    informationButton.addEventListener('click', async () => {
      if (informationBox.style.display === 'none' || informationBox.style.display === '') {
        informationBox.style.display = 'block';
      } else {
        informationBox.style.display = 'none';
      }
    });

    // Busca limites de data na API
    async function fetchDateLimits() {
      try {
        const resp = await fetch('/date-limits/');
        const data = await resp.json();

        const startDateInput = document.getElementById('start-date');
        const endDateInput   = document.getElementById('end-date');
        const clusterButton  = document.getElementById('generate-cluster');
        const infoMin        = document.getElementById('min-date-display');
        const infoMax        = document.getElementById('max-date-display');

        // Remove aviso anterior, se existir
        const oldAviso = document.getElementById('no-dates-msg');
        if (oldAviso) oldAviso.remove();

        if (data.limites) {
          // Só instancio as datas se houver limites válidos
          const start = new Date(data.start_date);
          const end   = new Date(data.end_date);
          const fmt = d => d.toISOString().slice(0,10);

          startDateInput.min = fmt(start);
          startDateInput.max = fmt(end);
          endDateInput.min   = fmt(start);
          endDateInput.max   = fmt(end);

          infoMin.textContent = fmt(start);
          infoMax.textContent = fmt(end);

          startDateInput.disabled = false;
          endDateInput.disabled   = false;
          clusterButton.disabled  = true;  // permanece bloqueado até o usuário escolher datas válidas
        } else {
          // Sem dados no banco: desabilita tudo e mostra mensagem
          startDateInput.disabled = true;
          endDateInput.disabled   = true;
          clusterButton.disabled  = true;

          infoMin.textContent = infoMax.textContent = '—';

          const aviso = document.createElement('p');
          aviso.id = 'no-dates-msg';
          aviso.textContent = 'Nenhuma data disponível para previsão.';
          aviso.style.color = 'red';
          // Insere logo após o parágrafo de intervalo
          infoMax.parentNode.appendChild(aviso);
        }
      } catch (err) {
        console.error('Erro ao buscar limites:', err);
      }
    }
    /*
    // Função genérica de requisição
    async function sendRequest(url, method, payload = {}) {
      const resp = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCSRFToken()
        },
        body: JSON.stringify(payload)
      });
      return resp.json();
    }
    */

    async function sendRequest(url, method, payload = null) {
      try {
        const options = {
          method: method.toUpperCase(),
          headers: {
            'Content-Type': 'application/json',
            // A alteração está aqui: usando sua função original
            'X-CSRFToken': getCSRFToken() 
          }
        };

        // Adiciona o body somente se houver dados e o método não for GET ou HEAD
        if (payload && options.method !== 'GET' && options.method !== 'HEAD') {
          options.body = JSON.stringify(payload);
        }

        const resp = await fetch(url, options);

        // Trata respostas de erro do servidor (ex: 404, 500)
        if (!resp.ok) {
          const errorData = await resp.json().catch(() => ({ message: `Erro HTTP: ${resp.status}` }));
          throw new Error(errorData.message || 'Ocorreu um erro no servidor.');
        }
        
        // Trata respostas que não têm conteúdo (ex: 204 No Content)
        const contentLength = resp.headers.get('content-length');
        if (contentLength && parseInt(contentLength, 10) > 0) {
          return await resp.json(); // Só faz o parse se houver corpo na resposta
        }
        
        return null; // Retorna null para respostas vazias

      } catch (err) {
        console.error(`Falha na requisição para ${url}:`, err);
        throw err; // Re-lança o erro para que o bloco catch do seu event listener possa capturá-lo
      }
    }

    trainModelButton.addEventListener('click', async () => {
        const selectedClusters = Array.from(document.querySelectorAll('input[name="cluster"]:checked'))
            .map(c => parseInt(c.value));

        const data = await sendRequest('/clients_profiles/train-model-a/', 'POST', {
            clusters: selectedClusters,
            start_date: startDateInput.value,
            end_date: endDateInput.value,
            forecast_period: forecastPeriodInput.value
        });

        const taskId = data.task_id;
        await pollTaskCSV(taskId);  // aqui espera terminar e baixa CSV
    });

/*
    trainModelButton.addEventListener('click', async () => {
        // Captura os clusters selecionados
        const selectedClusters = Array.from(document.querySelectorAll('input[name="cluster"]:checked'))
            .map(checkbox => parseInt(checkbox.value));  // Converte para número
        // Envia os clusters selecionados para o back-en

        const response = await fetch('/clients_profiles/train-model-a/', {
            method: 'POST',
            body: JSON.stringify({
                clusters: selectedClusters,
                start_date: startDateInput.value,
                end_date: endDateInput.value,
                forecast_period: forecastPeriodInput.value
            }),
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken()
            },
        });
        if (!response.ok) {
            throw new Error(`Erro ao treinar modelo: ${response.statusText}`);
        }
        // Convertendo a resposta para blob (arquivo)
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);

        // Criando um link para download
        const a = document.createElement('a');
        a.href = url;
        a.download = 'trained_models.csv';
        document.body.appendChild(a);
        a.click();
        if (!response.ok) {
            throw new Error(`Erro ao treinar modelo: ${response.statusText}`);
        }
        // Removendo o elemento após o download
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        console.log({response})
        if (data.error) {
            alert(data.error);
            return;
        }
        // Verifica se houve erro no envio
        if (sendResponse.error) {
            alert(sendResponse.error);
            return;
        }
        // Aguarda a resposta do back-end com o modelo treinado
        const trainedModelData = await sendRequest('/clients_profiles/train-model-a/', 'GET');
        // Verifica se houve erro ao receber os dados do modelo treinado
        if (trainedModelData.error) {
            alert(trainedModelData.error);
            return;
        }
        alert(trainedModelData.message);  // Mostra a mensagem que o back-end retorna
        console.log('Modelo Treinado:', trainedModelData); // Para depuração
        // Renderiza os gráficos com os dados
        renderCharts(trainedModelData.models);
    });
*/

    function handleCoordinates(coords) {
      if (!coords || !coords.length) {
          alert('Sem coordenadas para desenhar.');
          return;
      }

      // Normaliza os dados
      coords = coords.map(c => ({
          latitude: Number(c.latitude ?? c.lat ?? 0),
          longitude: Number(c.longitude ?? c.lon ?? 0),
          cluster: Number(c.cluster ?? c.cluster_id ?? 0),
          raw: c
      }));

      const MIN_ZOOM = 2;
      const MAX_ZOOM = 18;

      // Remove mapa antigo se existir, para recriação
      if (window.trainedMap) {
          window.trainedMap.remove();
          window.trainedMap = null;
      }

      // Inicializa mapa
      window.trainedMap = L.map('map', {
          center: [-15.7942, -47.8822],
          zoom: 5,
          minZoom: MIN_ZOOM,
          maxZoom: MAX_ZOOM,
          worldCopyJump: false
      }).setView([-15.7942, -47.8822], 5);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors',
          noWrap: true
      }).addTo(window.trainedMap);

      // LayerGroup para clusters
      if (window.clusterLayerGroup) {
          window.clusterLayerGroup.clearLayers();
      } else {
          window.clusterLayerGroup = L.layerGroup().addTo(window.trainedMap);
      }

      const colors = ['red','blue','green','orange','purple','cyan','magenta'];
      const uniqueClusters = [...new Set(coords.map(c => c.cluster))].sort((a,b)=>a-b);

      // Monta checkboxes
      const clusterForm = document.getElementById('cluster-form');
      clusterForm.innerHTML = '';
      document.getElementById('cluster-selection').style.display = 'block';

      uniqueClusters.forEach(cluster => {
          const lbl = document.createElement('label');
          lbl.style.display = 'inline-block';
          lbl.style.marginRight = '8px';
          // Checkboxes inicialmente **não marcados** como no código antigo
          lbl.innerHTML = `<input type="checkbox" name="cluster" value="${cluster}"> Cluster ${cluster}`;
          clusterForm.appendChild(lbl);
      });

      // Cria marcadores
      const markersByCluster = {};
      coords.forEach(coord => {
          if (!isFinite(coord.latitude) || !isFinite(coord.longitude)) return;

          const color = colors[coord.cluster % colors.length];
          const marker = L.circleMarker([coord.latitude, coord.longitude], {
              radius: 8,
              fillColor: color,
              color,
              weight: 1,
              opacity: 1,
              fillOpacity: 0.7
          });

          marker.bindTooltip(
              `Cluster: ${coord.cluster}<br>Lat: ${coord.latitude.toFixed(4)}<br>Lon: ${coord.longitude.toFixed(4)}`,
              { direction: 'top', offset: [0,-10], opacity: 0.9 }
          );

          marker.on('click', () => {
              const input = document.querySelector(`input[name="cluster"][value="${coord.cluster}"]`);
              if (input) input.checked = true;
          });

          marker.addTo(window.trainedMap);  // Adiciona diretamente como antes
          if (!markersByCluster[coord.cluster]) markersByCluster[coord.cluster] = [];
          markersByCluster[coord.cluster].push(marker);
      });

      // Evento para checkboxes (ligar/desligar clusters)
      clusterForm.querySelectorAll('input[name="cluster"]').forEach(input => {
          input.addEventListener('change', (ev) => {
              const val = Number(ev.target.value);
              const visible = ev.target.checked;
              (markersByCluster[val] || []).forEach(m => {
                  if (visible) window.trainedMap.addLayer(m);
                  else window.trainedMap.removeLayer(m);
              });
          });
      });

      // Ajusta bounds e padding igual ao código antigo
      const bounds = coords.map(c => [c.latitude, c.longitude]).filter(b => b[0] && b[1]);
      if (bounds.length) {
          const latlngBounds = L.latLngBounds(bounds);
          const paddedBounds = latlngBounds.pad(10);  // Mantém padding antigo
          window.trainedMap.setMaxBounds(paddedBounds);
          window.trainedMap.fitBounds(bounds);
      }

      setTimeout(() => window.trainedMap.invalidateSize(), 0);
  }
  
/*
    function handleCoordinates(coords) {
      if (!coords || !coords.length) {
        alert('Sem coordenadas para desenhar.');
        return;
      }

      coords = coords.map(c => ({
        latitude: Number(c.latitude ?? c.lat ?? 0),
        longitude: Number(c.longitude ?? c.lon ?? 0),
        cluster: Number(c.cluster ?? c.cluster_id ?? 0),
        raw: c
      }));

      // Inicializa mapa se necessário (com configs do "select_map_right")
      if (!window.trainedMap) {
        const MIN_ZOOM = 2;
        const MAX_ZOOM = 18;

        window.trainedMap = L.map('map', {
          center: [-15.7942, -47.8822],
          zoom: 5,
          minZoom: MIN_ZOOM,
          maxZoom: MAX_ZOOM,
          worldCopyJump: false
        }).setView([-15.7942, -47.8822], 5);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors',
          noWrap: true
        }).addTo(window.trainedMap);
      }

      if (window.clusterLayerGroup) {
        window.clusterLayerGroup.clearLayers();
      } else {
        window.clusterLayerGroup = L.layerGroup().addTo(window.trainedMap);
      }

      const colors = ['red','blue','green','orange','purple','cyan','magenta'];
      const uniqueClusters = [...new Set(coords.map(c => c.cluster))].sort((a,b)=>a-b);

      const clusterForm = document.getElementById('cluster-form');
      clusterForm.innerHTML = '';
      document.getElementById('cluster-selection').style.display = 'block';

      uniqueClusters.forEach(cluster => {
        const lbl = document.createElement('label');
        lbl.style.display = 'inline-block';
        lbl.style.marginRight = '8px';
        lbl.innerHTML = `<input type="checkbox" name="cluster" value="${cluster}" checked> Cluster ${cluster}`;
        clusterForm.appendChild(lbl);
      });

      const markersByCluster = {};
      coords.forEach(coord => {
        if (!isFinite(coord.latitude) || !isFinite(coord.longitude)) return;
        const color = colors[coord.cluster % colors.length];
        const marker = L.circleMarker([coord.latitude, coord.longitude], {
          radius: 8,
          fillColor: color,
          color,
          weight: 1,
          opacity: 1,
          fillOpacity: 0.7
        });

        marker.bindTooltip(
          `Cluster: ${coord.cluster}<br>Lat: ${coord.latitude.toFixed(4)}<br>Lon: ${coord.longitude.toFixed(4)}`,
          { direction: 'top', offset: [0,-10], opacity: 0.9 }
        );

        marker.on('click', () => {
          const input = document.querySelector(`input[name="cluster"][value="${coord.cluster}"]`);
          if (input) input.checked = true;
        });

        marker.addTo(window.clusterLayerGroup);
        if (!markersByCluster[coord.cluster]) markersByCluster[coord.cluster] = [];
        markersByCluster[coord.cluster].push(marker);
      });

      clusterForm.querySelectorAll('input[name="cluster"]').forEach(input => {
        input.addEventListener('change', (ev) => {
          const val = Number(ev.target.value);
          const visible = ev.target.checked;
          (markersByCluster[val] || []).forEach(m => {
            if (visible) window.clusterLayerGroup.addLayer(m);
            else window.clusterLayerGroup.removeLayer(m);
          });
        });
      });

      // Ajuste de bounds com padding (como no antigo)
      const bounds = coords.map(c => [c.latitude, c.longitude]).filter(b => b[0] && b[1]);
      if (bounds.length) {
        const latlngBounds = L.latLngBounds(bounds);
        const paddedBounds = latlngBounds.pad(0.1);
        window.trainedMap.setMaxBounds(paddedBounds);
        window.trainedMap.fitBounds(bounds);
      }

      setTimeout(() => window.trainedMap.invalidateSize(), 0);
    }
*/
    /*
    function handleCoordinates(coords) {
      // coords: array de objetos { latitude, longitude, cluster } (adicione mapeamento se seu backend usa lat/lon distintos)
      if (!coords || !coords.length) {
        alert('Sem coordenadas para desenhar.');
        return;
      }

      // garantir formato: converter strings para números se necessário
      coords = coords.map(c => ({
        latitude: Number(c.latitude ?? c.lat ?? c.latitud ?? 0),
        longitude: Number(c.longitude ?? c.lon ?? c.lng ?? c.long ?? 0),
        cluster: Number(c.cluster ?? c.cluster_id ?? 0),
        raw: c
      }));

      // Inicializa mapa se necessário (idempotente)
      if (!window.trainedMap) {
        window.trainedMap = L.map('map').setView([-15.7942, -47.8822], 5);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors'
        }).addTo(window.trainedMap);
      }

      // Limpar camada anterior (se existir)
      if (window.clusterLayerGroup) {
        window.clusterLayerGroup.clearLayers();
      } else {
        window.clusterLayerGroup = L.layerGroup().addTo(window.trainedMap);
      }

      // Prepara checkboxes
      const colors = ['red','blue','green','orange','purple','cyan','magenta'];
      const uniqueClusters = [...new Set(coords.map(c => c.cluster))].sort((a,b)=>a-b);

      const clusterForm = document.getElementById('cluster-form');
      clusterForm.innerHTML = '';
      document.getElementById('cluster-selection').style.display = 'block';

      uniqueClusters.forEach(cluster => {
        const lbl = document.createElement('label');
        lbl.style.display = 'inline-block';
        lbl.style.marginRight = '8px';
        lbl.innerHTML = `<input type="checkbox" name="cluster" value="${cluster}" checked> Cluster ${cluster}`;
        clusterForm.appendChild(lbl);
      });

      // Armazenar markers por cluster para poder ligar/desligar pela checkbox
      const markersByCluster = {};

      coords.forEach(coord => {
        // proteger contra coordenadas inválidas
        if (!isFinite(coord.latitude) || !isFinite(coord.longitude)) return;

        const color = colors[coord.cluster % colors.length];
        const marker = L.circleMarker([coord.latitude, coord.longitude], {
          radius: 8,
          fillColor: color,
          color,
          weight: 1,
          opacity: 1,
          fillOpacity: 0.7
        });

        marker.bindTooltip(
          `Cluster: ${coord.cluster}<br>Lat: ${coord.latitude.toFixed(4)}<br>Lon: ${coord.longitude.toFixed(4)}`,
          { direction: 'top', offset: [0,-10], opacity: 0.9 }
        );

        // adicionar evento para selecionar checkbox correspondente
        marker.on('click', () => {
          const input = document.querySelector(`input[name="cluster"][value="${coord.cluster}"]`);
          if (input) input.checked = true;
        });

        // adicionar ao layerGroup e ao índice por cluster
        marker.addTo(window.clusterLayerGroup);
        if (!markersByCluster[coord.cluster]) markersByCluster[coord.cluster] = [];
        markersByCluster[coord.cluster].push(marker);
      });

      // Ajusta comportamento das checkboxes: mostrar/ocultar markers
      clusterForm.querySelectorAll('input[name="cluster"]').forEach(input => {
        input.addEventListener('change', (ev) => {
          const val = Number(ev.target.value);
          const visible = ev.target.checked;
          const list = markersByCluster[val] || [];
          list.forEach(m => {
            if (visible) window.clusterLayerGroup.addLayer(m);
            else window.clusterLayerGroup.removeLayer(m);
          });
        });
      });

      // Ajusta bounds e força renderização
      const bounds = coords.map(c => [c.latitude, c.longitude]).filter(b => b[0] !== 0 || b[1] !== 0);
      if (bounds.length === 1) {
        window.trainedMap.setView(bounds[0], 13);
      } else if (bounds.length > 1) {
        window.trainedMap.fitBounds(bounds, { padding: [20, 20] });
      }
      setTimeout(() => window.trainedMap.invalidateSize(), 0);
    }
    */

    async function pollTaskCSV(taskId, interval = 2000, timeout = 180000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            const status = await sendRequest(`/clients_profiles/task-status/${taskId}/`, 'GET');
            if (!status) throw new Error('Erro ao verificar status da task');

            if (status.state === 'SUCCESS') {
            const fileId = status.file_id;  // <- pega o file_id do resultado da task
            console.log('Task CSV concluída, file_id:', fileId);
            const response = await fetch(`/download-trained-model/${fileId}/`);
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'trained_models.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            return; // download concluído
        }

            if (status.state === 'FAILURE') {
                throw new Error('Task falhou: ' + (status.error || JSON.stringify(status)));
            }

            // Task ainda PENDING/STARTED -> espera e re-tenta
            await new Promise(r => setTimeout(r, interval));
        }

        throw new Error('Timeout aguardando task CSV');
    }

    async function pollTask(taskId, interval = 2000, timeout = 180000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
          const status = await sendRequest(`/clients_profiles/task-status/${taskId}/`, 'GET');
          if (!status) throw new Error('Erro ao verificar status da task');
          if (status.state === 'SUCCESS') {
            // espera que o backend retorne region_id no result (ou coordinates diretamente)
            if (status.region_id) return { region_id: status.region_id };
            if (status.coordinates) return { coordinates: status.coordinates };
            // se não veio, ainda podemos checar result direto
            return status;
          }
          if (status.state === 'FAILURE') {
            throw new Error('Task falhou: ' + (status.error || JSON.stringify(status)));
          }
          // ainda PENDING/STARTED -> espera e re-tenta
          await new Promise(r => setTimeout(r, interval));
        }
        throw new Error('Timeout aguardando task (poll)');
      }

    clusterButton.addEventListener('click', async () => {
      resetInterface();

      // prevenir múltiplos cliques
      clusterButton.disabled = true;
      try {
        // 1) cria clusters (POST)
        const createResp = await sendRequest('/clients_profiles/create-cluster/', 'POST', {
          start_date: startDateInput.value,
          end_date: endDateInput.value,
          forecast_period: forecastPeriodInput.value
        });

        // opcional: checar createResp, mas você já disse que create_cluster funciona

        // 2) dispara definição de regiões
        const startResp = await sendRequest('/clients_profiles/define-regions-a/', 'POST');

        if (!startResp) {
          alert('Erro iniciando definição de regiões.');
          return;
        }

        // Se o backend retornou coordinates diretamente (caso raro), aceita imediatamente
        if (startResp.coordinates) {
          handleCoordinates(startResp.coordinates);
          return;
        }

        // Se backend retornou somente task_id -> polling
        if (!startResp.task_id) {
          alert('Resposta inesperada do servidor: sem task_id.');
          return;
        }

        // Mostrar feedback ao usuário enquanto aguarda (spinner, texto, etc.)
        showProcessingUI && showProcessingUI('Definindo regiões...');

        const pollResult = await pollTask(startResp.task_id, 2000, 180000); // 3 minutos
        // pollResult pode conter region_id ou coordinates
        let coords = null;
        if (pollResult.coordinates) coords = pollResult.coordinates;
        else if (pollResult.region_id) {
          // buscar resultado final
          const res = await sendRequest(`/clients_profiles/region-result/${pollResult.region_id}/`, 'GET');
          coords = res && res.coordinates ? res.coordinates : null;
        } else {
          // talvez o task retorne o objeto direto em res.result
          if (pollResult.result && pollResult.result.coordinates) coords = pollResult.result.coordinates;
        }

        if (!coords || !coords.length) {
          alert('Nenhuma região retornada pelo servidor.');
          return;
        }

        // chama seu bloco original — modularizado
        handleCoordinates(coords);

        // sucesso visual
        alert('Regiões definidas com sucesso!');
        trainModelButton.style.display = 'inline-block';

      } catch (err) {
        console.error('Erro no fluxo de criação de clusters:', err);
        alert('Erro ao definir regiões: ' + (err.message || err));
      } finally {
        hideProcessingUI && hideProcessingUI();
        clusterButton.disabled = false;
      }
    });

    /*
    // Listener do botão de criar cluster
    clusterButton.addEventListener('click', async () => {
      resetInterface();

      // 1) Cria clusters no back-end
      await sendRequest('/clients_profiles/create-cluster/', 'POST', {
        start_date: startDateInput.value,
        end_date: endDateInput.value,
        forecast_period: forecastPeriodInput.value
      });
      //const data2 = await sendRequest('/clients_profiles/define-regions-a/', 'POST');
      const startResp = await sendRequest('/clients_profiles/define-regions-a/', 'POST');

      //if (!data2 || !data2.coordinates) {
      //  alert('Erro ao definir regiões.');
      //  return;
      //}
      if (!startResp) {
        alert('Erro iniciando definição de regiões.');
        return;
      }

      if (startResp.coordinates) {
        handleCoordinates(startResp.coordinates);
        return;
      }
      if (!startResp.task_id) {
        alert('Resposta inesperada do servidor: sem task_id.');
        return;
      }

      try {
        // Poll até completar
        const result = await pollTask(startResp.task_id, 2000, 180000); // 3min timeout
        handleCoordinates(result.coordinates);
      } catch (err) {
        console.error(err);
        alert('Erro ao definir regiões: ' + err.message);
      }
      
      alert('Regiões definidas com sucesso!');
      trainModelButton.style.display = 'inline-block';

      // 2) Inicializa o mapa globalmente
      window.trainedMap = L.map('map').setView([-15.7942, -47.8822], 5);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(window.trainedMap);

      // 3) Monta checkboxes e marcadores
      const colors = ['red','blue','green','orange','purple','cyan','magenta'];
      const uniqueClusters = [...new Set(data2.coordinates.map(c => c.cluster))];
      const clusterForm = document.getElementById('cluster-form');
      clusterForm.innerHTML = '';
      document.getElementById('cluster-selection').style.display = 'block';

      // Prepara checkboxes
      uniqueClusters.forEach(cluster => {
        const lbl = document.createElement('label');
        lbl.innerHTML = `<input type="checkbox" name="cluster" value="${cluster}"> Cluster ${cluster}`;
        clusterForm.appendChild(lbl);
      });

      // Desenha marcadores
      data2.coordinates.forEach(coord => {
        const color = colors[coord.cluster % colors.length];
        L.circleMarker([coord.latitude, coord.longitude], {
          radius: 8,
          fillColor: color,
          color,
          weight: 1,
          opacity: 1,
          fillOpacity: 0.7
        })
        .addTo(window.trainedMap)
        .bindTooltip(
          `Cluster: ${coord.cluster}<br>Lat: ${coord.latitude.toFixed(4)}<br>Lon: ${coord.longitude.toFixed(4)}`,
          { direction: 'top', offset: [0,-10], opacity: 0.9 }
        )
        .on('click', () => {
          document.querySelector(`input[name="cluster"][value="${coord.cluster}"]`).checked = true;
        });
      });

      // 4) Ajusta bounds e força renderização
      const bounds = data2.coordinates.map(c => [c.latitude, c.longitude]);
      window.trainedMap.fitBounds(bounds);
      setTimeout(() => window.trainedMap.invalidateSize(), 0);
    });
    */

    // Inicialização
    startDateInput.addEventListener('change', toggleClusterButton);
    endDateInput.addEventListener('change', toggleClusterButton);
    forecastPeriodInput.addEventListener('input', toggleClusterButton);
    fetchDateLimits();
  });
</script>


</body>
</html>
{% endblock %}
