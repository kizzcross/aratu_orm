{% extends 'clients_profiles/base.html' %}

{% block title %}Mapa de Calor{% endblock %}

{% block content %}
<style>
  body {
    font-family: Arial, sans-serif;
  }
  #titulo {
    margin: 5px;
  }
  .form-group {
      margin-bottom: 1px;
      display: flex;
      flex-direction: column; /* Empilha os itens verticalmente */
      gap: 3px;
  }

  #data-preview table {
      border-collapse: collapse;
      width: 100%;
  }

  #data-preview th, #data-preview td {
      border: 1px solid #ddd;
      padding: 8px;
  }

  #data-preview th {
      background-color: #f2f2f2;
      text-align: left;
  }

  button {
      margin: 2px;
      padding: 5px 10px;
      border: none;
      background-color: #007BFF;
      color: white;
      cursor: pointer;
      border-radius: 5px;
  }

  button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
  }

  button:hover:not(:disabled) {
      background-color: #0056b3;
  }

  #data-preview {
      margin-top: 5px;
      padding: 5px;
      border: 1px solid #ccc;
      display: none;
  }

  #myChart {
      max-height: fit-content;/*300px;*/
      max-width: fit-content;
  }

  .chart {
      margin: 5px;
  }

  .line {
      fill: none;
      stroke-width: 2;
  }

  .line-real {
      stroke: steelblue;
  }

  .line-forecast {
      stroke: orange;
  }
  .plote-container {
    display: flex;
    height: 100%;
  }
  #map-container {
      min-height: 255px;
      height: calc(100vh - 376px); /* Ajuste 300px conforme a altura dos elementos acima do mapa */
      flex-grow: 1;
      width: 100%;
      margin: 2px;
  }
  #subtitulo {
      margin: 5px;
  }
  #cluster-form {
    display: flex;         /* Ativa o layout flexível */
    flex-wrap: wrap;       /* Permite que os itens quebrem para a próxima linha */
    gap: 3px 3px;        /* Adiciona espaçamento: 10px vertical, 20px horizontal */
  }

  #cluster-form label {
    /* Define uma base de largura para cada item. */
    /* O navegador tentará colocar o máximo de itens de 150px em cada linha. */
    flex-basis: 110px; 
    
    /* Evita que os itens encolham demais */
    flex-shrink: 0;
    
    /* Outras estilizações para deixar mais bonito */
    padding: 2px;
    border: 1px solid #eee;
    border-radius: 4px;
    background-color: #f9f9f9;
  }
  #cluster-selection {
    display: none;
    margin: 5px 0;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 5px;
  }
  #forecast-period {
    width: 100px; /* Ajuste o valor como preferir. 100px é um bom começo. */
  }
  #row-data-limits {
    margin: 3px;
    align-items: center;
    min-width: 205px;
  }
  fieldset {
    width: 211px;
    padding: 2px;
  }
  p {
    margin: 2px;
  }
  #data-config {
    display: flex;
    align-items: center; /* Centraliza verticalmente os itens */
    gap: 3px; /* Mantém o espaçamento entre os itens (se aplicável) */
  }
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
<body>
<h1 id="titulo">Air Quality Dashboard</h1>

<div>
  <h2 id="subtitulo">Importar Dados</h2>
  <button onclick="importData()">Importar Dados de Qualidade do Ar</button>
</div>

<div>
  <h2 id="subtitulo">Gerar Heatmap</h2>
  <div id="data-config">
  {% if perms.clients_profiles.view_airqualitydata %}
    <fieldset id="pmType">
      <legend>Selecione o(s) tipo(s) de PM:</legend>
      <label><input type="checkbox" name="pmType" value="pm1m"> PM1.0 (Massa)</label><br>
      <label><input type="checkbox" name="pmType" value="pm25m"> PM2.5 (Massa)</label><br>
      <label><input type="checkbox" name="pmType" value="pm4m"> PM4.0 (Massa)</label><br>
      <label><input type="checkbox" name="pmType" value="pm10m"> PM10 (Massa)</label>
    </fieldset>
    <div class="form-group">
      <div id="row-data-limits">
        <label for="start-date">Data de Início:</label>
        <input type="date" id="start-date" name="start-date" required disabled>
      </div>
      <div id="row-data-limits">
        <label for="end-date">Data de Fim:</label>
        <input type="date" id="end-date" name="end-date" required disabled>
      </div>
      <p>Intervalo de Datas: 
       <span id="min-date-display">—</span> até 
       <span id="max-date-display">—</span>
      </p>
      <p>Dados selecionados no intervalo: <span id="selected-count">0</span></p>
    </div>
  </div>
    <button id="btn-heatmap" onclick="generateHeatmap()" disabled>
      Gerar Heatmap
    </button>
  {% else %}
    <p class="text-danger">
      Você não tem permissão para acessar o heatmap de qualidade do ar.
    </p>
  {% endif %}
  <button id="information-button" type="button">?</button>
  <div id="information-box" style="display: none; border: 2px solid #00000088; margin-top: 10px;">
    <p id="info-interface">Variáveis da Interface:</p>
    <ul id="info-variables">
      <li>Data de Início: define a data inicial do intervalo a ser analisado.</li>
      <li>Data de Fim: define a data final do intervalo a ser analisado.</li>
      <li>PM: representa o tipo de material particulado, classificado de acordo com a sua massa.</li>
    </ul>
  </div>
</div>

<div id="map-container">
  <!-- mapa será injetado aqui -->
</div>
</body>
<script>
  // estado do mapa
  let map = null;
  let rawData = [];
  let heatLayer = null;

  document.addEventListener('DOMContentLoaded', () => {
    const s = document.getElementById('start-date');
    const e = document.getElementById('end-date');
    const pm = document.getElementById('pmType');
    const btn = document.getElementById('btn-heatmap');
    const infoMin = document.getElementById('min-date-display');
    const infoMax = document.getElementById('max-date-display');
    const informationButton = document.getElementById('information-button');
    const informationBox = document.getElementById('information-box');

    const isValidRange = () => {
      if (!s.value || !e.value) return false;
      return new Date(s.value) <= new Date(e.value);
    };

    const toggleButton = () => {
      btn.disabled = !isValidRange();
    };

    async function fetchDateLimits() {
      try {
        const resp = await fetch('/date-limits/');
        if (!resp.ok) {
          // 403 (sem permissão) ou erro de rede
          throw new Error('Não foi possível obter os limites de data.');
        }
        const data = await resp.json();

        // limpa aviso anterior
        const prev = document.getElementById('no-dates-msg');
        if (prev) prev.remove();

        if (data.limites && data.start_date && data.end_date) {
          const start = new Date(data.start_date);
          const end   = new Date(data.end_date);
          const fmt = d => d.toISOString().slice(0, 10);

          // define min/max e valores iniciais
          s.min = fmt(start); s.max = fmt(end); s.value = fmt(start);
          e.min = fmt(start); e.max = fmt(end); e.value = fmt(end);

          infoMin.textContent = fmt(start);
          infoMax.textContent = fmt(end);

          s.disabled = e.disabled = false;
          toggleButton();
        } else {
          // sem dados: desabilita tudo e mostra aviso
          s.disabled = e.disabled = true;
          btn.disabled = true;
          infoMin.textContent = infoMax.textContent = '—';

          const aviso = document.createElement('p');
          aviso.id = 'no-dates-msg';
          aviso.textContent = 'Nenhuma data disponível para gerar heatmap.';
          aviso.style.color = 'red';
          infoMax.parentNode.appendChild(aviso);
        }
      } catch (err) {
        console.error(err);
        alert('Erro ao carregar limites de data.');
      }
    }

    // listeners de UI
    s.addEventListener('change', toggleButton);
    e.addEventListener('change', toggleButton);

    // ao trocar o tipo de PM, refaz a busca (precisa novo "value" do backend)
    pm.addEventListener('change', () => {
      if (isValidRange()) generateHeatmap();
      updateSelectedCount();
    });

    // carrega limites assim que a página abre
    fetchDateLimits();

        // Exibe caixa de texto com explicações das variaveis
    informationButton.addEventListener('click', async () => {
      if (informationBox.style.display === 'none' || informationBox.style.display === '') {
        informationBox.style.display = 'block';
      } else {
        informationBox.style.display = 'none';
      }
    });
    
  });

let markerGroup = null; // Grupo de circleMarkers

async function generateHeatmap() {
    const pmType = document.getElementById('pmType').value;
    const startDate = document.getElementById('start-date').value;
    const endDate   = document.getElementById('end-date').value;

    if (!startDate || !endDate || new Date(startDate) > new Date(endDate)) {
        alert('Verifique as datas selecionadas.');
        return;
    }

    const selectedTypes = Array.from(document.querySelectorAll('input[name="pmType"]:checked'))
        .map(cb => cb.value);

    if (selectedTypes.length === 0) {
        alert('Selecione pelo menos um tipo de PM.');
        return;
    }

    const pmParam = selectedTypes.join(',');
    const url = `/clients_profiles/generate-heatmap/?start_date=${startDate}&end_date=${endDate}&pm_type=${pmParam}`;

    try {
        const response = await fetch(url);
        const jsonData = await response.json();

        if (jsonData.error) {
            alert(jsonData.error);
            return;
        }

        rawData = jsonData.data;
        document.getElementById('selected-count').textContent = rawData.length;

        const MIN_ZOOM = 2;
        const MAX_ZOOM = 18;

        if (!map) {
            map = L.map('map-container', {
                center: [-15.7942, -47.8822],
                zoom: 5,
                minZoom: MIN_ZOOM,
                maxZoom: MAX_ZOOM,
                worldCopyJump: false
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                noWrap: true
            }).addTo(map);
        }

        updateHeatmapLayer();

        const bounds = rawData.map(p => [p.lat, p.lon]);
        if (bounds.length > 0) {
            const latlngBounds = L.latLngBounds(bounds);
            map.setMaxBounds(latlngBounds.pad(0.1));
            map.fitBounds(latlngBounds.pad(0.1));
        }

    } catch (error) {
        alert('Erro ao buscar os dados do mapa de calor: ' + error);
    }
}

function updateHeatmapLayer() {
    if (!rawData || rawData.length === 0) return;

    const heatData = rawData.map(p => [p.lat, p.lon, p.value]);

    // Atualiza heatLayer
    if (heatLayer) {
        heatLayer.setLatLngs(heatData);
    } else {
        heatLayer = L.heatLayer(heatData, { radius: 25, blur: 15, maxZoom: 18 }).addTo(map);
    }

    // Atualiza os circleMarkers usando um layerGroup
    if (!markerGroup) {
        markerGroup = L.layerGroup().addTo(map);
    } else {
        markerGroup.clearLayers(); // remove markers antigos
    }

    // Adiciona markers novos
    rawData.forEach(p => {
        const circle = L.circleMarker([p.lat, p.lon], {
            radius: 5,             // menor tamanho melhora performance
            fillColor: 'transparent',
            color: 'transparent',
            weight: 0,
            fillOpacity: 0
        });

        circle.bindTooltip(`Concentração de Partículas: ${p.value.toFixed(2)}`, {
            permanent: false,
            direction: 'top'
        });

        markerGroup.addLayer(circle);
    });
}

function updateSelectedCount() {
    const selectedTypes = Array.from(document.querySelectorAll('input[name="pmType"]:checked'))
                               .map(cb => cb.value); // ['pm1m', 'pm25m']

    if (!rawData.length || !selectedTypes.length) {
        document.getElementById('selected-count').textContent = 0;
        return;
    }

    // Conta linhas que têm pelo menos um PM selecionado
    const count = rawData.filter(row => 
        selectedTypes.some(pm => row[pm] !== undefined && row[pm] !== null)
    ).length;

    document.getElementById('selected-count').textContent = count;
}

document.querySelectorAll('input[name="pmType"]').forEach(cb => cb.addEventListener('change', updateSelectedCount));


  function importData() {
    fetch('/sensor/import/')
      .then(r => r.json())
      .then(d => alert(d.message))
      .catch(e => alert('Erro na importação: ' + e));
  }
</script>


{% endblock %}